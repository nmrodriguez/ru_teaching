<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Semana 11</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr. Nicole Rodríguez" />
    <script src="libs/header-attrs-2.19/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/rutgers.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/rutgers-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Semana 11
]
.subtitle[
## Feedback and error correction
]
.author[
### Dr. Nicole Rodríguez
]
.institute[
### Rutgers University
]
.date[
### 2022/12/30 (updated: 2023-03-12)
]

---

class: middle, center, inverse

# Parte 1: Feedback and error correction pt. 1

---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - Recast
  
  - Clarification
  
  - Elicitation 
  
  - Metalinguistic 
  
  - Explicit corrective feedback
  
  - Repetition 
  
  - Explicit with metalinguistic 
  
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Recast**: implicit type of corrective feedback
  
    - Teacher tries to reformulate or expand the mistakes or incomplete sentences, words, or incomplete phrases 
    
    - Mention the correct form without telling that the incorrect form was incorrect
    
    - Example: "My father is long" "Yeah your father is tall"
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Clarification**: this is an elicitation of a reformulation or repetition from the students
  
    - phrases like "excuse me, sorry, I don't understand"
    
    - example: "How many years do you have?" "Oh I'm sorry? Could you rephrase the question?"
    
    - Its expected that the students will be able to realize their mistakes
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Elicitation**: teacher prompts the student to do self corrective feedback
    
    - teacher repeats what the student said incorrectly
    
    - they don't give the correct answer, but they only ask along with other students to produce the correct form
    
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Metalinguistic**: teacher provides comments, information, or questions related to incorrect utterances that students produced
  
    - Correct form is not directly given
    
    - Use of phrases like "Do we say it like that?" or "Remember when we talked about X grammar point?"
    
    - They give clues and its expected that the students will realize the errors they made
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Explicit corrective feedback**: teacher explicitly points out the mistake and provides the correct form of the word or phrase
  
    - No clues/keys/opportunity to self-reflect
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Repetition**: teacher repeats the error and changes the intonation 
  
    - Example: "I am have three sisters." "I am have?"
    
    - Expected that the students will be able to realize the sentence "I am have" is wrong
    
    
---
# Feedback 

- Types of corrective feedback on speaking performance: 

  - **Explicit with metalinguistic**: teacher corrects the mistake and then tells the student why they are wrong
  
  
---
class: center, middle

# The effectiveness of corrective feedback in SLA: a meta-analysis

## Shaofeng Li (2010)

---
# The effectiveness of corrective feedback in SLA: a meta-analysis

- Language learners have access to 2 types of input: positive evidence and negative evidence (Gass, 1997)

  - Positive evidence = informs the learner of what is acceptable in the target language and contains the "set of well-formed sentences to which learners are exposed
  
  - Negative evidence = provides the learner with information about the incorrectness of an L2 form or utterance and is often through the provision of corrective feedback in response to the learner's nontargetlike L2 production
  
.pull-left[

- Some researchers think SLA depends solely on positive evidence and that negative evidence is not necessary and might even be harmful


]
  
.pull-right[

- Some researchers acknowledge the importance of positive evidence, but maintain that negative evidence afforded through interactional feedback helps the learner notice the gap between nontargetlike L2 production and the target form
]

---
# The effectiveness of corrective feedback in SLA: a meta-analysis

- The role of corrective feedback is also grounded in Schmidt's (1990, 2001) noticing hypothesis

  - Unlike L1 acquisition, SLA is conscious
  
  - To enhance the learner's noticing of linguistic forms is through the provision of corrective feedback
  
  - Effects of feedback might also be attributable to uptake, which refers to the learner's responses to corrective feedback provided after a linguistic error or a query about a linguistic form
  
---
# The effectiveness of corrective feedback in SLA: a meta-analysis

- General findings from the meta-analysis: 

  - Recasts are the most frequent feedback type in the classroom
  
  - Recasts facilitate SLA
  
  - Different types of feedback have differential impact on SLA (i.e., explicit feedback is more effective than implicit feedback, prompts work better than recasts)
  
  - the occurrence of uptake varies in different contexts and is constrained by the characteristics of feedback
  
---
class: middle, center

# ¿Hace falta corregir todos los errores?

---
# Errores

- Errors are a fundamental part of learning

- Students often become uncomfortable/frustrated when they make mistakes in class, and error correction can be embarrassing 

- Need to emphasize that mistakes are a part of the learning process

  - we can't learn without errors
  
  - self-correction and peer correction are essential 

- Need to figure out when and how students want to be corrected in order to minimize negative feelings about error correction 

---
# Errores

- When to correct?

  - In appropriate moments or situations
  
  - Doing in constantly in class will hurt and halt student's from expressing themselves
  
  - Ideally, wait until the end of task, intervention, class, etc. 
  
    - Present the errors in a group 
    
---
# Errores

- What to correct?

  - All types of errors, not just grammar/lexical, but also syntax, cultural/semantic, and pronunciation 
  
  - But no need to correct every single error every time, just the most pressing matters at a time
  
---
background-image:  url("libs/img/sandwich.png")
background-size: contain


---
class: center, middle, inverse

# Descanso 

---
class: center, middle

# Feedback and error correction on unit plans

---
# Reflexión

- something about a time they felt uncomfortable in the language classroom because of errors 

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"link-citations": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
